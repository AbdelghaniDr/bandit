{"name":"Bandit","tagline":"Human friendly unit testing framework for C++11","body":"bandit\r\n======\r\n\r\nBandit is a framework for C++11 that wants to make working with unit tests a pleasant\r\nexperience.\r\n\r\nBandit is released under the [MIT license](LICENSE.md)\r\n\r\n#An example\r\n\r\nThis is a complete test application written in bandit:\r\n\r\n```cpp\r\n#include <bandit/bandit.h>\r\nusing namespace bandit;\r\n\r\ngo_bandit([](){\r\n\r\n    describe(\"fuzzbox:\", [](){\r\n      guitar_ptr guitar;\r\n      fuzzbox_ptr fuzzbox;\r\n\r\n      before_each([&](){\r\n        guitar = guitar_ptr(new struct guitar());\r\n        fuzzbox = fuzzbox_ptr(new struct fuzzbox());\r\n      });\r\n\r\n      before_each([&](){\r\n        guitar->add_effect(fuzzbox.get());\r\n      });\r\n\r\n      it(\"starts in clean mode\", [&](){\r\n        AssertThat(guitar->sound(), Equals(sounds::clean));\r\n      });\r\n\r\n      describe(\"in distorted mode\", [&](){\r\n\r\n        before_each([&](){\r\n          fuzzbox->flip();\r\n        });\r\n\r\n        it(\"sounds distorted\", [&](){\r\n          AssertThat(guitar->sound(), Equals(sounds::distorted));\r\n        });\r\n      });\r\n    });\r\n\r\n});\r\n\r\nint main(int argc, char* argv[])\r\n{\r\n  return bandit::run(argc, argv);\r\n}\r\n```\r\n\r\n#Installing\r\n\r\nBandit is header only so there is no need for additional compilation before you can start using it. Download bandit and add its root directory to your project's include directories and you're ready to go.\r\n\r\n#Running Tests\r\n\r\nWith bandit you create a command line application that runs all registered tests, reports the result\r\non stdout, and then exits with an error level 0 if all tests passed, and an error level greater\r\nthan 0 if some tests did not passed.\r\n\r\nEvery application needs an entry point, and for bandit it should look like this:\r\n\r\n```cpp\r\n#include <bandit/bandit.h>\r\n\r\nint main(int argc, char* argv[])\r\n{\r\n  return bandit::run(argc, argv);\r\n}\r\n```\r\n\r\nThe ```run()``` function will run all registered tests and report the result.\r\n\r\n##Command line arguments\r\n\r\nBandit enables you to tweak the way tests results are reported by allowing you to specify command\r\nline switches. Running ```[name of your executable] --help``` will list the available options.\r\n\r\n#Writing Tests\r\n\r\nOnce you have a command line application with an entry point that delegates to bandit, it's time to\r\nstart writing some tests.\r\n\r\nWe begin by adding a new .cpp file to our project. We then tell bandit that this file contains tests\r\nby using the ```go_bandit()``` construct:\r\n\r\n```cpp\r\n#include <bandit/bandit.h>\r\nusing namespace bandit;\r\n\r\ngo_bandit([](){\r\n\r\n  // Our tests goes here...\r\n\r\n});\r\n```\r\n\r\n##Describing things\r\n\r\nBandit is all about describing how pieces of your code should work. These descriptions can be \r\nbe executed to verify that they're accurate. Each description specifies how a certain piece of\r\nyour code behaves under certain conditions. \r\n\r\nAn example:\r\n\r\n```cpp\r\n#include <bandit/bandit.h>\r\nusing namespace bandit;\r\n\r\ngo_bandit([](){\r\n\r\n  describe(\"a turn based game\", [](){\r\n    game_ptr game;\r\n    player_ptr player_one, player_two;\r\n\r\n    // Setting up the game. More on this later...\r\n\r\n    it(\"is player one's turn\", [&}(){\r\n      AssertThat(game->whos_turn(), Equals(player_one));\r\n    });\r\n  });\r\n\r\n});\r\n```\r\n\r\n```describe()``` in this case describes a game with two players. ```it()``` verifies that when a new\r\ngame has just been created, it should be player one's turn to make a move.\r\n\r\n##Assertions\r\n\r\nThe example above uses [snowhouse](https://github.com/joakimkarlsson/snowhouse) for verifying that\r\nit actually is player one's turn to move.\r\n\r\nBandit comes bundled with snowhouse out of the box, but it is possible to use any assertion framework\r\nthat uses exceptions to notify us about errors. We need to create an adapter that translates from\r\nthe framework's exception to bandit's exceptions.\r\n\r\n##Setting up context\r\n\r\nWe need to be more specific about what it means to set up a game. This is what ```before_each()```\r\nand ```after_each()``` is for.\r\n\r\n```cpp\r\n#include <bandit/bandit.h>\r\nusing namespace bandit;\r\n\r\ngo_bandit([](){\r\n\r\n  describe(\"a turn based game\", [](){\r\n    game_ptr game;\r\n    player_ptr player_one, player_two;\r\n\r\n    before_each([&](){\r\n      game = game_ptr(new game());\r\n      player_one = player_ptr(new player(\"Player 1\"));\r\n      player_two = player_ptr(new player(\"Player 2\"));\r\n      game->add_player(*player_one);\r\n      game->add_player(*player_two);\r\n    });\r\n\r\n    it(\"is player one's turn\", [&}(){\r\n      AssertThat(game->whos_turn(), Equals(*player_one));\r\n    });\r\n  });\r\n\r\n});\r\n```\r\n\r\n```before_each()``` will be called before each ```it()``` method is called. This ensures that each \r\nmethods gets a fresh new context that hasn't been polluted by a previous test. If you need to restore\r\nthings after a test, you can user ```after_each()```, which will be called after each ```it()```\r\nmethod.\r\n\r\n#Nested descriptions\r\n\r\nThis is a power feature: you can nest descriptions. This will help you organize the different states\r\nthat the thing you're describing can be in. The outer context says \"here is this thing\" and nested\r\ncontexts can then say \"in this state\". This makes for descriptions that really conveys how a \r\ncomponent works under different conditions.\r\n\r\nAn example might be helpful:\r\n\r\n```cpp\r\n#include <bandit/bandit.h>\r\nusing namespace bandit;\r\n\r\ngo_bandit([](){\r\n\r\n  describe(\"a turn based game\", [](){\r\n    game_ptr game;\r\n    player_ptr player_one, player_two;\r\n\r\n    before_each([&](){\r\n      game = game_ptr(new game());\r\n      player_one = player_ptr(new player(\"Player 1\"));\r\n      player_two = player_ptr(new player(\"Player 2\"));\r\n      game->add_player(*player_one);\r\n      game->add_player(*player_two);\r\n    });\r\n\r\n    it(\"is player one's turn\", [&}(){\r\n      AssertThat(game->whos_turn(), Equals(*player_one));\r\n    });\r\n\r\n    describe(\"with all game positions filled\", [&](){\r\n\r\n      before_each([&](){\r\n        fill_all_positions(game);\r\n      });\r\n\r\n      it(\"considers the game a tie\", [&](){\r\n        AssertThat(game->winner(), Equals(TIE));\r\n      });\r\n    });\r\n\r\n    describe(\"player two has made a bad move\", [&](){\r\n    \r\n       before_each([&](){\r\n         make_a_bad_move(*player_two);\r\n       });\r\n       \r\n       it(\"considers player one the winner\", [&](){\r\n         AssertThat(game->winner(), Equals(PLAYER_ONE));\r\n       });\r\n    });\r\n    \r\n  });\r\n\r\n});\r\n```\r\n\r\nWhen bandit is about to call ```it(\"considers the game a tie\")```, it first calls all registered ```before_each()``` in the outermost ```describe()``` before it calls ```before_each()``` in the current ```describe()```. With several levels of nesting, bandit will start at the outermost ```describe()``` and work its way down the ancestor chain until it reaches the ```describe()``` where the current ```it()``` is found.\r\n\r\n```after_each()``` will be called after the call to ```it()``` starting at the describe function of the ```it()``` and working its way up the ancestor chain.\r\n\r\nThat way nested describes can augment the state set up by its parents, making the set up for each ```describe()``` pretty self explanatory even for components\r\nthat have a complex set of states.\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}